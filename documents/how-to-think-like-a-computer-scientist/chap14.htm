<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>제 14 장 : 클래스와 메쏘드(Classes and methods)</title>
<META http-equiv=Content-Type content="text/html; charset=utf-8">

<style type="text/css">
<!--
body {background-color: white; color: black;}
a {background-color: white; color: blue; text-decoration: underline;}
a:hover {text-decoration: none;}
td.head,td.headcenter {background-color: #99ccff; color: black;}
td.headcenter {width: 100%; text-align: center;}
img {border-style: none;}
-->
</style>


<style type="text/css">
<!--
.code {font-family: Courier; font-size: 85%;}
.keyword {color: #0000ff;}
.comment {color: #008000;}
.quote {color: #ff0000;}
.function {color: #0000ff;}
-->
</style>

</head>

<body>

<hr>
<table width="100%" cellpadding="0" cellspacing="2" border="0">
  <tr>
    <td width="20" class=head><a href="chap15.htm"><img border="0" alt="Next" src="images/next.png" ></a></td>
    <td width="20" class=head><a href="index.htm" ><img border="0" alt="Up" src="images/up.png" ></a></td>
    <td width="20" class=head><a href="chap13.htm" ><img border="0" alt="Previous" src="images/prev.png" ></a></td>
    <td width="100%" class=headcenter><img border="0" alt="Hi" src="images/headertitle.png" ></td>
    <td width="20" class=head><img border="0" alt="" src="images/blank.png" ></td>
    <td width="20" class=head><a href="dex.htm" ><img border="0" alt="Index" src="images/index.png" ></a></td>
    <td width="20" class=head><img border="0" alt="" src="images/blank.png" ></td>
  </tr>
</table>
<hr>


<h2>제 14 장</h2>

<h1>클래스와 메쏘드</h1>


<a name=1></a><br>
<h3>14.1 객체-지향적 특징</h3>

<p>
파이썬은 <b>객체-지향적 프로그래밍 언어(object-oriented programming language)</b>입니다. 다시 말하면 파이썬은 <b>객체-지향적 프로그래밍</b>이라는 특징을 지원합니다.</p>

<p>객체-지향적 프로그래밍을 정의하기는 쉽지 않지만, 이미 그런 특징들 몇 가지를 본적이 있습니다:</p>

<ul>

<li>프로그램은 객체 정의와 함수 정의로 구성된다. 그리고 대부분의 계산은 객체에 대한 연산이라는 관점에서 표현된다.</li>

<li>각 객체 정의는 실제 세계의 개념 또는 어떤 객체에 상응한다. 그 객체에 대하여 연산을 하는 함수는 실제-세계에 있는 객체들이 서로 상호작용하는 방식에 상응한다.</li>

</ul>

<p>
예를 들어 <a href="chap13.htm">제 13 장</a>에 정의된 <span class=code>Time</span> 클래스는 하루의 시간을 기록하는 방식에 상응합니다. 그리고 우리가 정의한 그 함수들은 사람들이 시간을 가지고 하는 일들에 상응합니다. 이와 비슷하게, <span class=code>Point</span>와 <span class=code>Rectangle</span> 클래스는 점과 사각형이라는 수학적 개념에 상응합니다.</p>

<p>
지금까지는 파이썬이 지원하는 객체-지향적 프로그래밍을 이용하지 않았습니다. 엄밀히 이야기 해서 이러한 특징이 반드시 필요한 것은 아닙니다. 대부분의 경우 이미 해 놓은 것들에 대하여 대안적인 구문을 제공합니다. 그러나 많은 경우에 그 대안이 더 간결하고 더 정확하게 프로그램의 구조를 전달합니다.</p>

<p>
예를 들어 <span class=code>Time</span> 프로그램을 살펴 보면, 클래스 정의와 그에 따르는 함수 정의 사이에 명확한 관계가 전혀 없습니다. 약간만 조사해 보면 모든 함수가 적어도 <span class=code>Time</span> 객체 하나는 매개변수로 취한다는 것을 알 수 있습니다.</p>

<p>
이러한 관찰이 바로 <b>메쏘드(methods)</b>를 도입하는 동기가 됩니다. 이미 본 적이 있는 메쏘드 중에는 사전에 요청하던 <span class=code>keys</span>와 <span class=code>values</span> 같은 메쏘드가 있습니다. 각 메쏘드는 클래스와 연관이 있고 그 클래스의 실체에 대하여 요청하도록 되어 있습니다.</p>



<p>메쏘드는 함수와 똑 같지만 두 가지 차이점이 있습니다:</p>

<ul>

<li>메쏘드는 클래스와 메쏘드 사이의 관계를 명시하기 하기 위하여 클래스 정의 안에 정의된다.</li>

<li>메쏘드(method)를 요청(invoking)하는 구문은 함수(function)를 호출(calling)하는 구문과 다르다.</li>

</ul>

<p>
다음 몇 섹션에서는 이전 두 장에서 함수들을 가져와서 메쏘드로 변경시켜 보겠습니다. 이 변경은 순수하게 기계적입니다; 단순히 일련의 단계를 따르기만 하면 변경할 수 있습니다. 한 형태에서 다른 형태로 변환시키는데 익숙해지면, 하고자하는 목적에 가장 좋은 형태를 선택할 수 있게 될 것입니다.</p>

<a name=2></a><br>
<h3>14.2 <span class=code>printTime</span></h3>

<p>
<a href="chap13.htm">제 13장</a>에서 <span class=code>Time</span>이라는 이름의 클래스 하나를 정의했습니다. 그리고 <span class=code>printTime</span>이라는 이름의 함수 하나를 작성했습니다. 이것을 코드로 보이면 다음과 같이 보일 것입니다:</p>


<p><span class=code><span class=keyword>class</span> Time:
<br>&nbsp; <span class=keyword>pass
<br>
<br>def</span> printTime(time):
<br>&nbsp; <span class=keyword>print</span> str(time.hours) + <span class=quote>":"</span> +
<br>&nbsp; &nbsp; &nbsp; &nbsp; str(time.minutes) + <span class=quote>":"</span> +
<br>&nbsp; &nbsp; &nbsp; &nbsp; str(time.seconds)
<br></span></p>



<p>
이 함수를 호출하기 위해 <span class=code>Time</span> 객체를 매개변수로 건네주었습니다:</p>


<p><span class=code>&gt;&gt;&gt; currentTime = Time()
<br>&gt;&gt;&gt; currentTime.hours = 9
<br>&gt;&gt;&gt; currentTime.minutes = 14
<br>&gt;&gt;&gt; currentTime.seconds = 30
<br>&gt;&gt;&gt; printTime(currentTime)
<br></span></p>



<p>
<span class=code>printTime</span>을 메쏘드로 변환하기 위해서 필요한 것은 함수 정의를 클래스 정의 안으로 이동시키기만 하면 됩니다. 들여쓰기에 변화가 있는 것을 주목하세요.</p>


<p><span class=code><span class=keyword>class</span> Time:
<br>&nbsp; <span class=keyword>def</span> <span class=function>printTime</span>(time):
<br>&nbsp; &nbsp; <span class=keyword>print</span> str(time.hours) + <span class=quote>":"</span> +
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str(time.minutes) + <span class=quote>":"</span> +
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str(time.seconds)
<br></span></p>



<p>
이제 점 표기법을 사용하면 <span class=code>printTime</span>을 요청할 수 있습니다.</p>
<p>
<span class=code>&gt;&gt;&gt; currentTime.printTime()
<br></span></p>
<p>
언제나 그렇듯이, 요청되는 메쏘드를 가진 객체는 점 앞에 나타나고 메쏘드의 이름은 점 뒤에 나타납니다.</p>
<p>
메쏘드가 요청되는 객체는 첫 번째 매개변수에 할당됩니다. 그래서 이 경우에는 <span class=code>currentTime</span>이 매개변수 <span class=code>time</span>에 할당됩니다.</p>

<p>
관례적으로 한 메쏘드의 첫 번째 매개변수를 <span class=code>self</span>라고 부릅니다. 이렇게 부르는 이유는 약간 복잡하지만 실용적인 은유에 기초하고 있습니다.</p>

<p>
함수 호출에 대한 구문인 <span class=code>printTime(currentTime)</span>을 보면 함수가 활성자(active agent)임을 볼 수 있습니다. 마치 다음과 같이 말하는 것 같습니다. "이봐 <span class=code>printTime</span>! 여기 자네가 인쇄할 객체가 하나 있어."</p>

<p>
객체-지향적 프로그래밍에서 객체는 활성자(active agents)입니다. <span class=code>currentTime.printTime()</span>와 같은 요청은 "이봐 <span class=code>currentTime</span>!  자신을 인쇄해 보게나!"라고 말하는 것과 같습니다.</p>

<p>
이러한 관점의 변화는 품격있어 보이기는 하지만 과연 쓸모가 있는지는 명확하지 않습니다. 지금까지 보아온 예제에서는 유용하지 않을 수도 있습니다. 그러나 종종 함수에서 객체로 책임을 떠 넘기게 되면 더욱 다재다능한 함수를 만들 수 있으며 더 쉽게 코드를 유지보수할 수 있고 재사용할 수 있습니다.</p>

<a name=3></a><br>
<h3>14.3 또다른 예제</h3>

<p>
이제 (<a href="chap13.htm#3">섹션 13.3</a>에서 발췌한) <span class=code>increment</span> 함수를 메쏘드로 변환해 봅시다. 공간 절약을 위해서 이전에 정의된 메쏘드들을 생략하겠습니다. 그러나 여러분의 버전에는 그 메쏘드들을 포함시켜 유지해야 합니다:</p>


<p><span class=code><span class=keyword>class</span> Time:
<br>&nbsp; <span class=comment>#previous method definitions here...
</span><br>
<br>&nbsp; <span class=keyword>def</span> <span class=function>increment</span>(self, secs):
<br>&nbsp; &nbsp; self.secs = secs + self.seconds
<br>
<br>&nbsp; &nbsp; <span class=keyword>while</span> self.seconds &gt;= 60:
<br>&nbsp; &nbsp; &nbsp; self.seconds = self.seconds - 60
<br>&nbsp; &nbsp; &nbsp; self.minutes = self.minutes + 1
<br>
<br>&nbsp; &nbsp; <span class=keyword>while</span> self.minutes &gt;= 60:
<br>&nbsp; &nbsp; &nbsp; self.minutes = self.minutes - 60
<br>&nbsp; &nbsp; &nbsp; self.hours = self.hours + 1
<br></span></p>



<p>
이 변경은 순수하게 기계적입니다---메쏘드 정의를 클래스 정의로 옮기고 첫 번째 매개변수의 이름을 변경합니다.</p>

<p>
이제 <span class=code>increment</span>를 메쏘드로 요청할 수 있습니다.</p>


<p><span class=code>currentTime.increment(500)
<br></span></p>



<p>
또 다시 메쏘드가 요청되고 있는 그 객체는 첫 번째 매개변수인 <span class=code>self</span>에 할당되고 있습니다. 두 번째 매개변수인 <span class=code>secs</span>는 <span class=code>500</span>이라는 값을 얻습니다.</p>

<p style="margin-left: 30px; margin-right: 30px;"> <i>연습으로, (<a href="chap13.htm#5" tppabs="http://www.ibiblio.org/obp/thinkCSpy/chap13.htm#5">섹션 13.5</a>에 있는) <span class=code>convertToSeconds</span> 함수를 <span class=code>Time</span> 클래스에 메쏘드로 변환해 넣어 보세요.</i> </p>

<a name=4></a><br>
<h3>14.4 더욱 복잡한 예제</h3>

<p><span class=code>after</span> 함수는 한 개가 아니라 두 개의 <span class=code>Time</span> 객체에 대해 연산을 하기 때문에 약간 더 복잡합니다. <span class=code>self</span>에 건네지는 매개변수중 하나만을 변환할 수 있으며; 나머지 매개변수는 그대로 있어야 합니다:</p>


<p><span class=code><span class=keyword>class</span> Time:
<br>&nbsp; <span class=comment>#이전의 메쏘드 정의가 위치할 곳...
</span><br>
<br>&nbsp; <span class=keyword>def</span> <span class=function>after</span>(self, time2):
<br>&nbsp; &nbsp; <span class=keyword>if</span> self.hour &gt; time2.hour:
<br>&nbsp; &nbsp; &nbsp; <span class=keyword>return</span> 1
<br>&nbsp; &nbsp; <span class=keyword>if</span> self.hour &lt; time2.hour:
<br>&nbsp; &nbsp; &nbsp; <span class=keyword>return</span> 0
<br>
<br>&nbsp; &nbsp; <span class=keyword>if</span> self.minute &gt; time2.minute:
<br>&nbsp; &nbsp; &nbsp; <span class=keyword>return</span> 1
<br>&nbsp; &nbsp; <span class=keyword>if</span> self.minute &lt; time2.minute:
<br>&nbsp; &nbsp; &nbsp; <span class=keyword>return</span> 0
<br>
<br>&nbsp; &nbsp; <span class=keyword>if</span> self.second &gt; time2.second:
<br>&nbsp; &nbsp; &nbsp; <span class=keyword>return</span> 1
<br>&nbsp; &nbsp; <span class=keyword>return</span> 0
<br></span></p>



<p>
이 메쏘드를 한 객체에 요청하고 다른 객체를 인자로 건네줍니다:</p>


<p><span class=code><span class=keyword>if</span> doneTime.after(currentTime):
<br>&nbsp; <span class=keyword>print</span> <span class=quote>"The bread will be done after it starts."</span>
<br></span></p>



<p>
거의 영어처럼 위의 호출을 다음과 같이 읽을 수 있습니다: "만약 완료-시간(done-time)이 현재-시간(current-time)의 뒤에 있다면, 그러면..."</p>

<a name=5></a><br>
<h3>14.5 선택적 인자</h3>

<p>
가변 개수의 인자들을 취하는 내장 함수들을 본 적이 있습니다. 예를 들어, <span class=code>string.find</span>는 인자를 둘이나 셋 또는 네개 가질 수 있습니다.</p>

<p>
선택적 인자 리스트를 가지는 사용자-정의 함수를 작성할 수 있습니다. 예를 들어, 앞서 만든 <span class=code>find</span> 버전을 업그레이드하여 <span class=code>string.find</span>가 하는 일과 똑 같은 일을 할 수 있습니다.</p>

<p>
다음은 <a href="chap07.htm#7">섹션 7.7</a>에서 발췌한 원래 버전입니다:</p>


<p><span class=code><span class=keyword>def</span> <span class=function>find</span>(str, ch):
<br>&nbsp; index = 0
<br>&nbsp; <span class=keyword>while</span> index &lt; len(str):
<br>&nbsp; &nbsp; <span class=keyword>if</span> str[index] == ch:
<br>&nbsp; &nbsp; &nbsp; <span class=keyword>return</span> index
<br>&nbsp; &nbsp; index = index + 1
<br>&nbsp; <span class=keyword>return</span> -1
<br></span></p>



<p>
다음은 새롭게 개선된 버전입니다:</p>


<p><span class=code><span class=keyword>def</span> <span class=function>find</span>(str, ch, start=0):
<br>&nbsp; index = start
<br>&nbsp; <span class=keyword>while</span> index &lt; len(str):
<br>&nbsp; &nbsp; <span class=keyword>if</span> str[index] == ch:
<br>&nbsp; &nbsp; &nbsp; <span class=keyword>return</span> index
<br>&nbsp; &nbsp; index = index + 1
<br>&nbsp; <span class=keyword>return</span> -1
<br></span></p>



<p>
세 번째 매개변수인 <span class=code>start</span>는 기본 값으로 <span class=code>0</span>이 주어지기 때문에 선택적입니다. 오직 인자 두 개만으로 <span class=code>find</span>를 요청한다면 주어진 기본 값을 그 문자열의 시작점으로 사용하여 시작합니다:</p>


<p><span class=code>&gt;&gt;&gt; find(<span class=quote>"apple"</span>, <span class=quote>"p"</span>)
<br>1
<br></span></p>



<p>
세 번째 매개변수를 제공하면 그 매개변수는 기본 값을 <b>덮어씁니다</b>:</p>


<p><span class=code>&gt;&gt;&gt; find(<span class=quote>"apple"</span>, <span class=quote>"p"</span>, 2)
<br>2
<br>&gt;&gt;&gt; find(<span class=quote>"apple"</span>, <span class=quote>"p"</span>, 3)
<br>-1
<br></span></p>



<p style="margin-left: 30px; margin-right: 30px;"> <i>연습으로, 네 번째 매개변수로 <span class=code>end</span>를 추가하여 탐색을 중지할 곳을 지정해 보세요. 
<p> 경고: 이 연습문제는 약간 꼼수적입니다. <span class=code>end</span>의 기본 값은 반드시 <span class=code>len(str)</span>이 되어야 하지만 <span class=code>len(str)</span>은 작동하지 않습니다. 기본 값은 함수가 호출될 때가 아니라 함수가 정의될 때 평가됩니다. <span class=code>find</span>가 정의될 때, <span class=code>str</span>은 아직 존재하지 않습니다, 그렇기 때문에 그 길이를 알 수 없습니다.</i> </p>

<a name=6></a><br>
<h3>14.6 초기화 메쏘드</h3>
<p>
<b>초기화 메쏘드(initialization method)</b>는 객체가 만들어질 때 요청되는 특수 메쏘드입니다. 이 메쏘드의 이름은 <span class=code>__init__</span>입니다. (밑줄 문자가 두 개 있고 다음에 <span class=code>init</span>이 따르며, 그리고 나서 다시 밑줄 문자가 두 개 더 있습니다). <span class=code>Time</span> 클래스에 대한 초기화 메쏘드는 다음과 같이 보입니다:</p>


<p><span class=code><span class=keyword>class</span> Time:
<br>&nbsp; <span class=keyword>def</span> <span class=function>__init__</span>(self, hours=0, minutes=0, seconds=0):
<br>&nbsp; &nbsp; self.hours = hours
<br>&nbsp; &nbsp; self.minutes = minutes
<br>&nbsp; &nbsp; self.seconds = seconds
<br></span></p>



<p>
속성인 <span class=code>self.hours</span>와 매개변수인 <span class=code>hours</span> 사이에는 아무 충돌이 없습니다. 점 표기법으로 어느 변수를 가리키고 있는지 지정하고 있기 때문입니다.</p>

<p>
<span class=code>Time</span> 구성자(constructor)를 요청하면 인자는 <span class=code>init</span>에 건네집니다:</p>


<p><span class=code>&gt;&gt;&gt; currentTime = Time(9, 14, 30)
<br>&gt;&gt;&gt; currentTime.printTime()
<br>&gt;&gt;&gt; 9:14:30
<br></span></p>



<p>
매개변수는 선택적이기 때문에 매개변수를 생략할 수 있습니다:</p>


<p><span class=code>&gt;&gt;&gt; currentTime = Time()
<br>&gt;&gt;&gt; currentTime.printTime()
<br>&gt;&gt;&gt; 0:0:0
<br></span></p>



<p>또는 오직 첫 번째 매개변수만 제공해도 됩니다:</p>


<p><span class=code>&gt;&gt;&gt; currentTime = Time (9)
<br>&gt;&gt;&gt; currentTime.printTime()
<br>&gt;&gt;&gt; 9:0:0
<br></span></p>



<p>또는 앞쪽의 매개변수 두 개만 넘겨주어도 됩니다:</p>


<p><span class=code>&gt;&gt;&gt; currentTime = Time (9, 14)
<br>&gt;&gt;&gt; currentTime.printTime()
<br>&gt;&gt;&gt; 9:14:0
<br></span></p>



<p>
마지막으로 이름을 명시적으로 지정함으로써 매개변수의 하부모둠을 제공할 수 있습니다:</p>


<p><span class=code>&gt;&gt;&gt; currentTime = Time(seconds = 30, hours = 9)
<br>&gt;&gt;&gt; currentTime.printTime()
<br>&gt;&gt;&gt; 9:0:30
<br></span></p>



<a name=7></a><br>
<h3>14.7 점 심화연구</h3>

<p>
<a href="chap12.htm#1">섹션 12.1</a>에 있는 <span class=code>Point</span> 클래스를 더욱 객체-지향적인 스타일로 다시 작성하여 봅시다:</p>


<p><span class=code><span class=keyword>class</span> Point:
<br>&nbsp; <span class=keyword>def</span> <span class=function>__init__</span>(self, x=0, y=0):
<br>&nbsp; &nbsp; self.x = x
<br>&nbsp; &nbsp; self.y = y
<br>
<br>&nbsp; <span class=keyword>def</span> <span class=function>__str__</span>(self):
<br>&nbsp; &nbsp; <span class=keyword>return</span> <span class=quote>'('</span> + str(self.x) + <span class=quote>', '</span> + str(self.y) + <span class=quote>')'</span>
<br></span></p>



<p>
초기화 메쏘드는 <tt>x</tt>와 <tt>y</tt> 값을 선택적 매개변수로 취합니다; 두 매개변수의 기본 값은 각각 0입니다.</p>

<p>
다음 메쏘드인 <span class=code>__str__</span>은 <span class=code>Point</span> 객체의 문자열 표현을 반환합니다. 만약 클래스가 <span class=code>__str__</span>이라는 이름의 메쏘드를 제공한다면, 파이썬에 내장된 <span class=code>str</span>함수의 기본 행위를 덮어씁니다.</p>


<p><span class=code>&gt;&gt;&gt; p = Point(3, 4)
<br>&gt;&gt;&gt; str(p)
<br><span class=quote>'(3, 4)'</span>
<br></span></p>



<p>
<span class=code>Point</span> 객체를 인쇄하면 묵시적으로 그 객체에 <span class=code>__str__</span>을 요청합니다. 그렇기 때문에 <span class=code>__str__</span>을 정의하면 <span class=code><span class=keyword>print</span></span>의 행위에도 영향을 미칩니다:</p>


<p><span class=code>&gt;&gt;&gt; p = Point(3, 4)
<br>&gt;&gt;&gt; <span class=keyword>print</span> p
<br>(3, 4)
<br></span></p>



<p>
클래스를 새로 하나 작성하게 되면 거의 언제나 <span class=code>__init__</span>과 <span class=code>__str__</span>을 작성함으로써 시작합니다. <span class=code>__init__</span> 덕분에 더 쉽게 객체들을 실체화할 수 있고 <span class=code>__str__</span> 덕분에 더 편하게 디버깅할 수 있습니다.</p>

<a name=8></a><br>
<h3>14.8 연산자 오버로딩</h3>

<p>
어떤 언어에서는 내장 연산자들이 사용자-정의 유형에 적용될 때 그 정의를 변경할 수 있습니다. 이러한 특징을 <b>연산자 오버로딩(operator overloading)</b>이라고 부릅니다. 특히 새로운 수학적 유형을 정의할 때 쓸모가 있습니다.</p>

<p>
예를 들어, 덧셈 연산자인 <span class=code>+</span>를 덮어쓰려면 <span class=code>__add__</span>라는 이름의 메쏘드를 제공합니다:</p>


<p><span class=code><span class=keyword>class</span> Point:
<br>&nbsp; <span class=comment># 이전에 정의된 메쏘드들이 위치할 곳...
</span><br>
<br>&nbsp; <span class=keyword>def</span> <span class=function>__add__</span>(self, other):
<br>&nbsp; &nbsp; <span class=keyword>return</span> Point(self.x + other.x, self.y + other.y)
<br></span></p>



<p>
여느 때와 같이 첫 번째 매개변수는 메소드가 요청되는 객체입니다. 두 번째 매개변수는 편리하게도 <span class=code>other</span>라고 이름지어져서 <span class=code>self</span>와 구별됩니다. <span class=code>Point</span> 두 개를 더하기 위해는 <tt>x</tt> 좌표의 합과 <tt>y</tt> 좌표의 합을 담고 있는 <span class=code>Point</span>를 하나 새로 만들어 반환합니다.</p>

<p>
이제 <span class=code>+</span> 연산자를 <span class=code>Point</span> 객체에 적용하면 파이썬은 <span class=code>__add__</span>을 요청합니다:</p>


<p><span class=code>&gt;&gt;&gt;&nbsp; &nbsp;p1 = Point(3, 4)
<br>&gt;&gt;&gt;&nbsp; &nbsp;p2 = Point(5, 7)
<br>&gt;&gt;&gt;&nbsp; &nbsp;p3 = p1 + p2
<br>&gt;&gt;&gt;&nbsp; &nbsp;<span class=keyword>print</span> p3
<br>(8, 11)
<br></span></p>



<p>
다음 표현식 <span class=code>p1 + p2</span>는 <span class=code>p1.__add__(p2)</span>와 동등하지만 확실히 더 우아합니다.</p>

<p style="margin-left: 30px; margin-right: 30px;"> <i>연습으로, <span class=code>__sub__(self, other)</span> 메쏘드를 추가하여 뺄셈 연산자를 덮어쓰고, 한번 시험해 보세요.</i> </p>

<p>
여러가지 방법으로 곱셈 연산자의 행위를 덮어쓸 수 있습니다: <span class=code>__mul__</span>이라는 이름의 메쏘드를 정의하거나 <span class=code>__rmul__</span>이라는 이름의 메쏘드를 정의하거나 또는 두 메쏘드 모두를 정의함으로써 말입니다.</p>

<p>
만약 <span class=code>*</span>의 왼쪽에 있는 피연산자가 <span class=code>Point</span>라면 파이썬은 <span class=code>__mul__</span>을 요청합니다. 이 메쏘드는 다른 쪽 피연산자도 <span class=code>Point</span>라고 가정합니다. 선형 대수학의 규칙에 따라 정의된 두 점의 <b>점적(dot product)</b>을 계산합니다:</p>


<p><span class=code><span class=keyword>def</span> <span class=function>__mul__</span>(self, other):
<br>&nbsp; <span class=keyword>return</span> self.x * other.x + self.y * other.y
<br></span></p>



<p>
만약 <span class=code>*</span>의 왼쪽에 있는 피연산자가 기본 유형(primitive type)이고 오른쪽 피연산자가 <span class=code>Point</span>라면 파이썬은 <span class=code>__rmul__</span> 메쏘드를 호출하는데, 이 메쏘드는 <b>스칼라 곱셈(scalar multiplication)</b>을 수행합니다:</p>


<p><span class=code><span class=keyword>def</span> <span class=function>__rmul__</span>(self, other):
<br>&nbsp; <span class=keyword>return</span> Point(other * self.x,&nbsp; other * self.y)
<br></span></p>



<p>
결과는 새로운 <span class=code>Point</span>이며 그 좌표는 원래 좌표들의 곱입니다. 만약 <span class=code>other</span>가 부동-소수점 수로 곱해질 수 없는 유형이라면, <span class=code>__rmul__</span>은 에러를 산출할 것입니다.</p>

<p>
다음 예제는 위에 예시한 두 종류의 곱셈을 보여줍니다:</p>


<p><span class=code>&gt;&gt;&gt; p1 = Point(3, 4)
<br>&gt;&gt;&gt; p2 = Point(5, 7)
<br>&gt;&gt;&gt; <span class=keyword>print</span> p1 * p2
<br>43
<br>&gt;&gt;&gt; <span class=keyword>print</span> 2 * p2
<br>(10, 14)
<br></span></p>



<p>
<span class=code>p2 * 2</span>를 평가하고자 하면 무슨 일이 일어나는가? 첫 번째 매개변수는 <span class=code>Point</span>이기 때문에 파이썬은 <span class=code>2</span>를 두 번째 인자로 하여 <span class=code>__mul__</span>을 요청합니다. <span class=code>__mul__</span> 메쏘드 안에서 프로그램은 <span class=code>other</span>의 <span class=code>x</span> 좌표에 접근을 시도합니다. 그렇지만 이 시도는 정수에 그 속성이 없기 때문에 실패합니다:</p>


<p><span class=code>&gt;&gt;&gt; <span class=keyword>print</span> p2 * 2
<br>AttributeError: <span class=quote>'int'</span> object has no attribute <span class=quote>'x'</span>
<br></span></p>



<p>
불행하게도 에러 메시지는 약간 이해하기 어렵습니다. 이 예제는 객체-지향 프로그래밍이 어려운 경우를 보여줍니다. 어떤때는 어떤 코드가 실행되고 있는지 알기 어렵습니다.</p>

<p>
연산자 덮어쓰기에 대한 더 완전한 예제를 보려면 <a href="app02.htm">부록 B</a>를 보세요.</p>

<a name=9></a><br>
<h3>14.9 다형성(Polymorphism)</h3>

<p>
지금까지 작성한 메쏘드는 대부분 오로지 특정한 유형에 대해서만 작동합니다. 객체를 하나 새로 만들때 그 유형에 대해 작용하는 메쏘드들을 만듭니다.</p>

<p>
그러나 어떤 연산에 대해서는 이전 섹션에서 사용한 수리적 연산처럼 여러 유형에 적용하고 싶어할 경우가 있습니다. 만약 여러 유형이 같은 연산 모둠을 지원한다면, 그러한 형태라면 어느 것에도 작동하는 함수를 작성할 수 있습니다.</p>

<p>
예를 들어, (선형 대수학에서 자주 볼 수 있는) <span class=code>multadd</span> 연산은 매개변수를 세 개 취합니다; 앞의 매개변수 두 개를 곱해서 세 번째 매개변수에 더합니다. 파이썬으로는 다음과 같이 작성할 수 있습니다:</p>


<p><span class=code><span class=keyword>def</span> <span class=function>multadd</span> (x, y, z):
<br>&nbsp; <span class=keyword>return</span> x * y + z
<br></span></p>


<p>
이 메쏘드는 <span class=code>x</span>와 <span class=code>y</span>가 곱해질 수 있는 값이기만 하면 작동할 것이고 <span class=code>z</span>의 값이 그 곱에 더해질 수 있기만 하면 작동할 것입니다.</p>

<p>
수치 값을 가지고 이 메쏘드를 요청할 수 있습니다:</p>


<p><span class=code>&gt;&gt;&gt; multadd (3, 2, 1)
<br>7
<br></span></p>



<p>또는 <span class=code>Point</span>를 가지고 요청할 수도 있습니다:</p>


<p><span class=code>&gt;&gt;&gt; p1 = Point(3, 4)
<br>&gt;&gt;&gt; p2 = Point(5, 7)
<br>&gt;&gt;&gt; <span class=keyword>print</span> multadd (2, p1, p2)
<br>(11, 15)
<br>&gt;&gt;&gt; <span class=keyword>print</span> multadd (p1, p2, 1)
<br>44
<br></span></p>



<p>
첫 번째 경우에, <span class=code>Point</span>는 스칼라값 하나와 곱해지고 나서 또다른 <span class=code>Point</span>에 더해집니다. 두 번째 경우에, 점적(dot product)은 수치 값을 산출합니다. 그래서 세 번째 매개변수도 역시 수치값이 되어야 합니다.</p>

<p>
이와 같이 서로 다른 유형을 가진 매개변수들을 취할 수 있는 함수를 <b>다형적(polymorphic)</b>이라고 부릅니다.</p>

<p>
또 다른 예제로 <span class=code>frontAndBack</span> 메쏘드를 고찰해 봅시다. 이 메쏘드는 리스트 하나를 앞으로 거꾸로 두 번 인쇄합니다:</p>


<p><span class=code><span class=keyword>def</span> <span class=function>frontAndBack</span>(front):
<br>&nbsp; <span class=keyword>import</span> copy
<br>&nbsp; back = copy.copy(front)
<br>&nbsp; back.reverse()
<br>&nbsp; <span class=keyword>print</span> str(front) + str(back)
<br></span></p>



<p>
<span class=code>reverse</span> 메쏘드는 변경자이기 때문에 거꾸로 하기 전에 먼저 리스트의 복사본을 만듭니다. 그러므로, 이 메쏘드는 매개변수로 받아들이는 리스트를 변경하지 않습니다.</p>

<p>
다음 예제에서 <span class=code>frontAndBack</span>을 리스트에 적용해 봅니다:</p>


<p><span class=code>&gt;&gt;&gt;&nbsp; &nbsp;myList = [1, 2, 3, 4]
<br>&gt;&gt;&gt;&nbsp; &nbsp;frontAndBack(myList)
<br>[1, 2, 3, 4][4, 3, 2, 1]
<br></span></p>



<p>
물론, 이 함수를 리스트에 적용하고자 하였으므로 작동해도 놀랄만한 일은 아닙니다. 정말로 놀랄만한 것은 이 함수를 <span class=code>Point</span>에도 적용할 수 있다는 것입니다.</p>

<p>
함수가 새로운 유형에 적용될 수 있을지를 결정하기 위해서는 다형성의 기본 규칙을 적용합니다:</p>

<p style="margin-left: 30px; margin-right: 30px;">한 함수 안의 모든 연산이 한 유형에 적용될 수 있다면, 그 함수는 그 유형에 적용될 수 있습니다.</p>

<p>
이 메쏘드에 있는 연산은 <span class=code>copy</span>와 <span class=code>reverse</span> 그리고 <span class=code><span class=keyword>print</span></span>입니다.</p>

<p>
<span class=code>copy</span>는 어떤 객체에도 작동합니다. 그리고 이미 <span class=code>Point</span>에 대하여 <span class=code>__str__</span> 메쏘드를 작성하였습니다. 그래서 <span class=code>Point</span> 클래스에 필요한 것은 <span class=code>reverse</span> 메쏘드 뿐입니다:</p>


<p><span class=code><span class=keyword>def</span> <span class=function>reverse</span>(self):
<br>&nbsp; self.x , self.y = self.y, self.x
<br></span></p>



<p>그러면 <span class=code>Point</span>를 <span class=code>frontAndBack</span>에 건네줄 수 있습니다:</p>


<p><span class=code>&gt;&gt;&gt;&nbsp; &nbsp;p = Point(3, 4)
<br>&gt;&gt;&gt;&nbsp; &nbsp;frontAndBack(p)
<br>(3, 4)(4, 3)
<br></span></p>



<p>
가장 훌륭한 다형성은 예상하지 못한 다형성입니다. 종종 이미 작성해 놓은 함수가 전혀 생각지도 못했던 유형에 대하여 적용될 수도 있다는 것을 발견하곤 합니다.</p>

<a name=10></a><br>
<h3>14.10 용어 해설</h3>

<dl>

<dt>객체-지향적 언어(object-oriented language)</dt>
<dd>객체-지향적 프로그래밍을 편리하게 해주는, 예를 들어 사용자-정의 클래스와 상속과 같은 특징을 제공하는 언어.</dd>

<dt>객체-지향적 프로그래밍(object-oriented programming)</dt>
<dd>데이타와 그 데이타를 조작하는 연산이 클래스와 메쏘드로 조직된 프로그래밍 스타일.</dd>

<dt>메쏘드(method)</dt>
<dd>클래스 정의 안에 정의되고 그 클래스의 실체에 요청되는 함수.</dd>

<dt>오버라이드(override)</dt>
<dd>기본 값을 대치하는 것. 예제에서는 기본 매개변수를 특별한 인자로 대치하는 예와, 같은 이름을 가진 메쏘드를 새로 제공함으로써 기본 메쏘드를 대치하는 예를 보여주고 있다.</dd>

<dt>초기화 메쏘드(initialization method)</dt>
<dd>객체가 새로 만들어질 때 자동으로 요청되는 특수 메쏘드로서 그 객체의 속성들을 초기화 한다.</dd>

<dt>연산자 오버로딩(operator overloading)</dt>
<dd>내장 연산자들을 (<span class=code>+</span>, <span class=code>-</span>, <span class=code>*</span>, <span class=code>&gt;</span>, <span class=code>&lt;</span>, 등등.) 확장하여 사용자-정의 유형과 작동시키는 것.</dd>

<dt>점 적(dot product)</dt>
<dd>선형 대수학에 정의되어 있는 연산으로 두개의 <span class=code>Point</span>를 곱해 수치값을 산출한다.</dd>

<dt>스칼라 곱(scalar multiplication)</dt>
<dd>선형 대수학에 정의되어 있는 연산으로서 <span class=code>Point</span>의 각 좌표들에 일정 수치만큼 곱한다.</dd>

<dt>다형함수(polymorphic)</dt>
<dd>하나 이상의 유형에 대하여 작용하는 함수. 함수 안에 있는 모든 연산이 한 유형에 적용될 수 있다면, 그 함수는 한 유형에 적용될 수 있다.</dd>



</dl>
<h2>연습문제</h2>
<ol>
<li><div class="exercise">
다음 함수 <code>convertToSeconds</code>를 :
<pre class="python">
def convertToSeconds(t):
    minutes = t.hours * 60 + t.minutes
    seconds = minutes * 60 + t.seconds
    return seconds
</pre>
<code>Time</code> 클래스에 메쏘드로 넣어라.
</div></li>

<li><div class="exercise">
<code>find</code> 함수에 네번째 매개변수 <code>end</code>를 추가하여, 어디에서 찾기를 멈출지 지정하라.
<br /><br />
경고: 이 연습문제는 약간 어렵다. <code>end</code>의 기본 값은 <code>len(str)</code>이어야 하지만, 작동하지 않는다.  기본 값은 함수가 호출될 때가 아니라 정의될 때 평가된다. <code>find</code> 함수가 정의될 때, 아직 <code>str</code>은 존재하지 않는다. 그래서 그의 길이를 알 수 없다.
</div></li>

<li><div class="exercise">
 &nbsp;
</div></li>
</ol>

<p>
<hr>
<table width="100%" cellpadding="0" cellspacing="2" border="0">
  <tr>
    <td width="20" class=head><a href="chap15.htm"><img border="0" alt="Next" src="images/next.png" ></a></td>
    <td width="20" class=head><a href="index.htm"><img border="0" alt="Up" src="images/up.png" ></a></td>
    <td width="20" class=head><a href="chap13.htm"><img border="0" alt="Previous" src="images/prev.png" ></a></td>
    <td width="100%" class=headcenter><img border="0" alt="Hi" src="images/headertitle.png"></td>
    <td width="20" class=head><img border="0" alt="" src="images/blank.png"></td>
    <td width="20" class=head><a href="dex.htm"><img border="0" alt="Index" src="images/index.png" ></a></td>
    <td width="20" class=head><img border="0" alt="" src="images/blank.png"></td>
  </tr>
</table>
<hr>

</body>
</html>
