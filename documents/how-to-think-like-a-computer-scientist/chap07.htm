<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>제 7 장 : 문자열(Strings)</title>
<META http-equiv=Content-Type content="text/html; charset=utf-8">

<style type="text/css">
<!--
body {background-color: white; color: black;}
a {background-color: white; color: blue; text-decoration: underline;}
a:hover {text-decoration: none;}
td.head,td.headcenter {background-color: #99ccff; color: black;}
td.headcenter {width: 100%; text-align: center;}
img {border-style: none;}
-->
</style>


<style type="text/css">
<!--
.code {font-family: Courier; font-size: 85%;}
.keyword {color: #0000ff;}
.comment {color: #008000;}
.quote {color: #ff0000;}
.function {color: #0000ff;}
-->
</style>

</head>

<body>

<hr>
<table width="100%" cellpadding="0" cellspacing="2" border="0">
  <tr>
    <td width="20" class=head><a href="chap08.htm"><img border="0" alt="Next" src="images/next.png" ></a></td>
    <td width="20" class=head><a href="index.htm"><img border="0" alt="Up" src="images/up.png" ></a></td>
    <td width="20" class=head><a href="chap06.htm" ><img border="0" alt="Previous" src="images/prev.png" ></a></td>
    <td width="100%" class=headcenter><img border="0" alt="Hi" src="images/headertitle.png" ></td>
    <td width="20" class=head><img border="0" alt="" src="images/blank.png" ></td>
    <td width="20" class=head><a href="dex.htm" ><img border="0" alt="Index" src="images/index.png" ></a></td>
    <td width="20" class=head><img border="0" alt="" src="images/blank.png" ></td>
  </tr>
</table>
<hr>


<h2>제 7 장</h2>

<h1>문자열</h1>


<a name=1></a><br>
<h3>7.1 복합 데이타 유형</h3>
<p>
지금까지 세 가지의 유형을 보았습니다: <span class=code>int</span>와 <span class=code>float</span> 그리고 <span class=code>string</span>이 그것입니다. 문자열은(Strings) 다른 두 유형과 질적으로 다릅니다. 문자열은 더 작은 조각들로 구성되기 때문입니다---즉 문자들로 구성됩니다.</p>
<p>
더 작은 조각들로 구성되는 유형들을 복합 데이타 유형(<b>compound data types</b>)이라고 부릅니다. 무엇을 하고자 하느냐에 따라 복합 데이타 유형을 하나의 개체로 다룰 수도 있고, 또는 일부분에 접근할 수도 있습니다. 이 모호성은 유용하게 사용됩니다.</p>
<p>
다음 각괄호 연산자는 문자열로부터 문자 한 개를 선택합니다.</p>


<p><span class=code>&gt;&gt;&gt; fruit = <span class=quote>"banana"</span>
<br>&gt;&gt;&gt; letter = fruit[1]
<br>&gt;&gt;&gt; <span class=keyword>print</span> letter
<br></span></p>



<p>
다음 표현식 <span class=code>fruit[1]</span>은 <span class=code>fruit</span>로부터 1번 문자를 선택합니다. 변수 <span class=code>letter</span>는 그 결과를 가르킵니다. <span class=code>letter</span>를 인쇄해 보면 당황스럽습니다:</p>


<p><span class=code>a
<br></span></p>



<p>
<span class=code><span class=quote>"banana"</span></span>의 첫 번째 문자는 <span class=code>a</span>가 아닙니다. 기이한 이유 때문에 컴퓨터과학자들은 항상 0에서부터 수를 세기 시작합니다. <span class=code><span class=quote>"banana"</span></span>의 0번째 기호("zero-eth")는 <span class=code>b</span>입니다. 첫 번째 기호("one-eth")는 <span class=code>a</span>입니다. 그리고 두 번째("two-eth") 기호는 <span class=code>n</span>입니다.</p>
<p>
만약 문자열에서 0-번째 기호를 원한다면, 각괄호 안에 0을 넣거나 또는 0 값을 가지는 표현식을 넣으면 됩니다:</p>


<p><span class=code>&gt;&gt;&gt; letter = fruit[0]
<br>&gt;&gt;&gt; <span class=keyword>print</span> letter
<br>b
<br></span></p>



<p>
각괄호 안에 있는 표현식을 지표(<b>index</b>)라고 부릅니다. 지표는 순서있는 모둠에서 구성원을 지정합니다. 이 경우에는 문자열에서 문자 집합을 지정하고 있습니다. 지표는 어느 것을 원하는지 <i>가리킵니다</i>. 그러니까 그 이름을 가리킵니다. 지표는 어떠한 정수 표현식도 될 수 있습니다.</p>



<a name=2></a><br>
<h3>7.2 길이</h3>

<p>
<span class=code>len</span> 함수는 문자열에서 문자의 개수를 돌려 줍니다:</p>


<p><span class=code>&gt;&gt;&gt; fruit = <span class=quote>"banana"</span>
<br>&gt;&gt;&gt; len(fruit)
<br>6
<br></span></p>



<p>
문자열의 마지막 문자를 얻으려고 다음과 같이 시도하고 싶을 수 있습니다:</p>


<p><span class=code>length = len(fruit)
<br>last = fruit[length]&nbsp; &nbsp; &nbsp; &nbsp;<span class=comment># ERROR!
</span><br></span></p>



<p>
작동하지 않는군요. 실행시간 에러(<span class=code>IndexError: string index out of range(범위를 벗어난 문자열 지표)</span>)를 야기합니다. 이유는 <span class=code><span class=quote>"banana"</span></span>에 6번째 기호가 전혀 없다는 것입니다. 0에서부터 수를 세기 시작했으므로, 여섯 개의 기호들은 0에서 5까지 번호가 매겨집니다. 마지막 문자를 얻으려면, 길이(<span class=code>length</span>)에서 1을 빼야만 합니다:</p>

<p><span class=code>length = len(fruit)
<br>last = fruit[length-1]
<br></span></p>

<p>
또다른 방법으로, 음의 지표를 사용할 수 있습니다. 음의 지표는 문자열의 끝에서부터 거꾸로 셉니다. 다음 표현식 <span class=code>fruit[-1]</span>는 마지막 문자를 산출합니다, <span class=code>fruit[-2]</span>는 마지막에서 두 번째 문자를 산출합니다, 등등.</p>



<a name=3></a><br>
<h3>7.3 순회와 <span class=code><span class=keyword>for</span></span> 회돌이</h3>

<p>
계산은 한 번에 한 문자씩 문자열을 처리하는 것과 많이 연관되어 있습니다. 종종 계산이 처음에 시작되면 각 문자를 순서대로 선택하고, 선택된 문자에 무엇인가 처리를 하고 끝날 때까지 반복합니다. 이러한 처리 패턴을 순회(<b>traversal</b>)라고 부릅니다. 순회를 코딩하는 한가지 방법은 <span class=code><span class=keyword>while</span></span> 서술문으로 코딩하는 것입니다:</p>


<p><span class=code>index = 0
<br><span class=keyword>while</span> index &lt; len(fruit):
<br>&nbsp; letter = fruit[index]
<br>&nbsp; <span class=keyword>print</span> letter
<br>&nbsp; index = index + 1
<br></span></p>



<p>
이 회돌이는 문자열을 순회해서 문자를 각 줄에 따로따로 표시합니다. 회돌이 조건은 <span class=code>index &lt; len(fruit)</span>입니다. 그래서 <span class=code>index</span>가 문자열의 길이와 같으면, 그 조건은 거짓이 되고 회돌이의 몸체는 실행되지 않습니다. 가장 마지막으로 접근한 문자는 지표로 <span class=code>len(fruit)-1</span>을 가진 문자입니다. 이 문자는 문자열에서 가장 마지막 문자입니다.</p>

<p style="margin-left: 30px; margin-right: 30px;"> <i>연습으로, 문자열을 인자로 취해 문자를 거꾸로 한 줄에 한 개씩 출력하는 함수를 작성해 보세요.</i> </p>

<p>
지표를 사용하여 한 모둠의 값들을 순회하는 것은 너무나 흔한 일이어서 파이썬은 더 간단한 구문을 대안으로 제공합니다--- <span class=code><span class=keyword>for</span></span> 회돌이가 그것입니다:</p>


<p><span class=code><span class=keyword>for</span> char <span class=keyword>in</span> fruit:
<br>&nbsp; <span class=keyword>print</span> char
<br></span></p>



<p>
회돌이를 통과할 때마다 문자열에서 다음 문자가 <span class=code>char</span> 변수에 할당됩니다. 회돌이는 문자가 하나도 남지 않을 때까지 계속됩니다.</p>



<p>
다음 예제는 ABC순서의 연속물을 생성하기 위하여 결합(concatenation)과 <span class=code><span class=keyword>for</span></span> 회돌이를 사용하는 법을 보여줍니다. "ABC순서의(Abecedarian)"라는 것은 그 요소들이 알파벳 순서로 나타나는 목록 혹은 연속물을 지칭합니다. 예를 들어, 로버트 맥클로스키(Robert McCloskey)의 책인 <i>오리새끼들을 위해 길을 만들기(Make Way for Ducklings)</i>에서, 오리새끼들의 이름은 Jack, Kack, Lack, Mack, Nack, Ouack, Pack, 그리고 Quack입니다. 이 회돌이는 이러한 이름들을 순서대로 출력합니다:</p>


<p><span class=code>prefixes = <span class=quote>"JKLMNOPQ"</span>
<br>suffix = <span class=quote>"ack"</span>
<br>
<br><span class=keyword>for</span> letter <span class=keyword>in</span> prefixes:
<br>&nbsp; <span class=keyword>print</span> letter + suffix
<br></span></p>



<p>이 프로그램의 출력결과는 다음과 같습니다:</p>


<p><span class=code>Jack
<br>Kack
<br>Lack
<br>Mack
<br>Nack
<br>Oack
<br>Pack
<br>Qack
<br></span></p>



<p>
물론, "Ouack"과 "Quack"의 철자가 잘못 되었기 때문에 완전히 옳지는 않습니다.</p>

<p style="margin-left: 30px; margin-right: 30px;"> <i>연습으로, 프로그램을 수정하여 이 에러를 고쳐 보세요.</i> </p>

<a name=4></a><br>
<h3>7.4 문자열 조각</h3>
<p>
문자열의 한 부분을 조각(<b>slice</b>)이라고 부릅니다. 조각을 선택하는 것은 하나의 문자를 선택하는 것과 비슷합니다:</p>


<p><span class=code>&gt;&gt;&gt; s = <span class=quote>"Peter, Paul, and Mary"</span>
<br>&gt;&gt;&gt; <span class=keyword>print</span> s[0:5]
<br>Peter
<br>&gt;&gt;&gt; <span class=keyword>print</span> s[7:11]
<br>Paul
<br>&gt;&gt;&gt; <span class=keyword>print</span> s[17:21]
<br>Mary
<br></span></p>



<p>
연산자 <span class=code>[n:m]</span>은 문자열의 부분을 "n-번째" 문자에서부터 "m-번째" 문자까지 돌려줍니다. 첫 번째 문자(n)는 포함하지만 마지막 문자(m)는 제외하고 말입니다. 이러한 행태는 직관에 어긋납니다; 지표가 문자열들 <i>사이</i>를 지적하는 것이라고 상상해보면 더 잘 이해가 갑니다. 다음 다이어그램에서와 같이 말입니다:</p>

<p align="center"><img src="illustrations/banana.png"></p>

<p>
(쌍점 앞에 있는) 첫 번째 지표를 생략한다면, 조각은 문자열의 처음에서 시작합니다. 두 번째 지표를 생략한다면, 조각은 문자열의 끝까지 갑니다. 그리하여:</p>


<p><span class=code>&gt;&gt;&gt; fruit = <span class=quote>"banana"</span>
<br>&gt;&gt;&gt; fruit[:3]
<br><span class=quote>'ban'</span>
<br>&gt;&gt;&gt; fruit[3:]
<br><span class=quote>'ana'</span>
<br></span></p>



<p><span class=code>s[:]</span>이 무엇을 뜻한다고 생각하십니까?</p>

<a name=5></a><br>
<h3>7.5 문자열 비교</h3>

<p>비교 연산자들은 문자열에 작동합니다. 문자열 두 개가 같은지 알아 보려면:</p>


<p><span class=code><span class=keyword>if</span> word == <span class=quote>"banana"</span>:
<br>&nbsp; <span class=keyword>print</span>&nbsp; <span class=quote>"Yes, we have no bananas!"</span>
<br></span></p>



<p>다른 비교 연산들은 단어들을 알파벳 순서로 배치하는데 유용하게 사용됩니다:</p>


<p><span class=code><span class=keyword>if</span> word &lt; <span class=quote>"banana"</span>:
<br>&nbsp; <span class=keyword>print</span> <span class=quote>"Your word,"</span> + word + <span class=quote>", comes before banana."</span>
<br><span class=keyword>elif</span> word &gt; <span class=quote>"banana"</span>:
<br>&nbsp; <span class=keyword>print</span> <span class=quote>"Your word,"</span> + word + <span class=quote>", comes after banana."</span>
<br><span class=keyword>else</span>:
<br>&nbsp; <span class=keyword>print</span> <span class=quote>"Yes, we have no bananas!"</span>
<br></span></p>



<p>
그렇지만, 유념해야 할 것은 파이썬은 인간이 처리하는 것과 똑 같은 방식으로 대문자와 소문자를 취급하지 않는다는 것입니다. 대문자 기호는 소문자 기호 앞에 옵니다. 결과적으로 다음과 같이 됩니다:</p>


<p><span class=code>Your word, Zebra, comes before banana.
<br></span></p>



<p>
이 문제에 접근하는 일반적인 방법은 비교를 수행하기 전에 문자열들을 표준 형식으로, 예를 들어 모두 소문자로 변환하는 것입니다. 정말 더 어려운 문제는 프로그램에게 얼룩말(zebras)이 과일(fruit)이 아니라는 것을 인식시키는 일입니다.</p>

<a name=6></a><br>
<h3>7.6 문자열은 변경불능이다</h3>

<p>
<span class=code>[ ]</span> 연산자를 할당문의 왼쪽에 사용하고 싶은 유혹이 있습니다. 문자열에서 문자 하나를 변경하고자 하는 의도로 말입니다. 예를 들어:</p>


<p><span class=code>greeting = <span class=quote>"Hello, world!"</span>
<br>greeting[0] = <span class=quote>'J'</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class=comment># ERROR!
</span><br><span class=keyword>print</span> greeting
<br></span></p>



<p>
이 코드는 출력결과로 <span class=code>Jello, world!</span>를 산출하는 대신에, 실행시간 에러를 만들어 냅니다. </P>
<P><span class=code>TypeError: object doesn't support item assignment</span>.<BR>
<span class=code>TypeError: 객체가 항목 할당을 지원하지 않는다</span>.
</p>



<p>
문자열은 변경불능(<b>immutable</b>)입니다. 이것은 기존의 문자열을 변경할 수 없다는 것을 뜻합니다. 최선의 방법은 원래 문자열을 변조해서 문자열을 새롭게 만드는 것입니다:</p>


<p><span class=code>greeting = <span class=quote>"Hello, world!"</span>
<br>newGreeting = <span class=quote>'J'</span> + greeting[1:]
<br><span class=keyword>print</span> newGreeting
<br></span></p>



<p>
여기에서의 해결책은 새로운 첫 번째 문자를 <span class=code>greeting</span>의 조각에 결합하는 것입니다. 이 연산은 원래 문자열에 전혀 영향을 미치지 않습니다.</p>



<a name=7></a><br>
<h3>7.7 <span class=code>find</span> 함수</h3>

<p>다음의 함수는 무슨 일을 하는가?</p>


<p><span class=code><span class=keyword>def</span> <span class=function>find</span>(str, ch):
<br>&nbsp; index = 0
<br>&nbsp; <span class=keyword>while</span> index &lt; len(str):
<br>&nbsp; &nbsp; <span class=keyword>if</span> str[index] == ch:
<br>&nbsp; &nbsp; &nbsp; <span class=keyword>return</span> index
<br>&nbsp; &nbsp; index = index + 1
<br>&nbsp; <span class=keyword>return</span> -1
<br></span></p>



<p>
어떤 면에서, <span class=code>find</span> 함수는 <span class=code>[ ]</span> 연산자의 정반대입니다. 지표 하나를 취해 그에 상응하는 문자를 추출하는 대신에, <span class=code>find</span> 함수는 문자 하나를 취해 그 문자가 나타나는 지표를 찾습니다. 만약 그 문자가 발견되지 않으면, 이 함수는 <span class=code>-1</span>을 돌려줍니다.</p>
<p>
이 예제에서 처음으로 회돌이 안에 있는 <span class=code><span class=keyword>return</span></span> 서술문을 보고 있습니다. <span class=code>str[index] == ch</span>이면, 함수는 회돌이를 일찌감치 빠져 나와서 즉시 복귀합니다.</p>
<p>
그 문자가 문자열에 나타나지 않으면, 프로그램은 회돌이를 정상적으로 빠져나오고 <span class=code>-1</span>을 반환합니다.</p>
<p>
이러한 계산 패턴을 때로는 "유레카(eureka)" 순회라고 부릅니다. 왜냐하면 찾고자 하는 것을 발견하자 마자, "유레카(Eureka)!"라고 외치며 찾기를 멈출 수 있기 때문입니다.</p>

<p style="margin-left: 30px; margin-right: 30px;"> <i>연습으로, <span class=code>find</span> 함수를 수정하여 세 번째 매개변수를 취하도록 해보세요. 그 매개변수는 문자열에서 찾기를 시작해야 할 지표입니다.</i> </p>

<a name=8></a><br>
<h3>7.8 회돌이와 횟수세기</h3>

<p>
다음 프로그램은 문자 <span class=code>a</span>가 문자열에 나타나는 횟수를 셉니다:</p>


<p><span class=code>fruit = <span class=quote>"banana"</span>
<br>count = 0
<br><span class=keyword>for</span> char <span class=keyword>in</span> fruit:
<br>&nbsp; <span class=keyword>if</span> char == <span class=quote>'a'</span>:
<br>&nbsp; &nbsp; count = count + 1
<br><span class=keyword>print</span> count
<br></span></p>

<p>
이 프로그램은 횟수세기(<b>counter</b>)라고 부르는 또다른 계산 패턴을 보여줍니다. 변수 <span class=code>count</span>는 0으로 초기화됩니다. 그리고 <span class=code>a</span>가 발견될 때마다 증가합니다. (증가한다(<b>increment</b>)라는 것은 하나씩 증가한다는 뜻입니다; 반대말은 감소하다(<b>decrement</b>)입니다. "배설물(excrement)"과 관계가 전혀 없으며 이 단어는 명사입니다.) 회돌이가 종료하면, <span class=code>count</span>에 그 결과가 담깁니다---<span class=code>a</span>가 나타난 총 횟수가 담겨 있습니다.</p>

<p style="margin-left: 30px; margin-right: 30px;"> <i>연습으로, 이 코드를 <span class=code>countLetters</span>라는 이름의 함수에 캡슐화해 넣어보세요. 그리고 그 함수를 일반화해 문자열과 기호를 매개변수로 받아들이도록 해 보세요.</i> </p>

<p style="margin-left: 30px; margin-right: 30px;"> <i>두 번째 연습으로, 이 함수를 재작성해 문자열을 순회하는 대신에, 매개변수가 세 개 있는 이전의 <span class=code>find</span> 버전을 사용하도록 해 보세요.</i> </p>

<a name=9></a><br>
<h3>7.9 <span class=code>string</span> 모듈</h3>

<p>
<span class=code>string</span> 모듈에는 문자열을 처리하는 유용한 함수들이 담겨 있습니다. 평소와 같이 모듈을 먼저 반입해야만 사용할 수 있습니다:</p>


<p><span class=code>&gt;&gt;&gt; <span class=keyword>import</span> string
<br></span></p>

<p>
<span class=code>string</span> 모듈에는 지금까지 작성했던 함수와 똑같은 일을 하는 <span class=code>find</span>라는 이름의 함수가 있습니다. 이 함수를 호출하려면 점 표기법을 사용하여 모듈의 이름과 함수의 이름을 지정해야 합니다.</p>


<p><span class=code>&gt;&gt;&gt; fruit = <span class=quote>"banana"</span>
<br>&gt;&gt;&gt; index = string.find(fruit, <span class=quote>"a"</span>)
<br>&gt;&gt;&gt; <span class=keyword>print</span> index
<br>1
<br></span></p>


<p>
이 예제는 모듈이 가지는 장점들 중의 하나를 보여줍니다--모듈 덕분에 내장 함수와 사용자-정의 함수 사이의 이름 충돌을 피할 수 있습니다. 점 표기법을 사용하면 어느 <span class=code>find</span> 버전을 원하는지 지정할 수 있습니다.</p>
<p>
실제로, <span class=code>string.find</span>는 우리의 버전보다 더욱 일반적입니다. 무엇보다도이 함수는 단지 문자들뿐만 아니라 부분문자열을 찾을 수 있습니다:</p>


<p><span class=code>&gt;&gt;&gt; string.find(<span class=quote>"banana"</span>, <span class=quote>"na"</span>)
<br>2
<br></span></p>



<p>
또, 인자를 하나 더 받아 탐색을 시작해야 할 지표를 지정합니다:</p>


<p><span class=code>&gt;&gt;&gt; string.find(<span class=quote>"banana"</span>, <span class=quote>"na"</span>, 3)
<br>4
<br></span></p>



<p>
또는, 인자를 두개 더 취해 지표의 범위를 지정합니다:</p>


<p><span class=code>&gt;&gt;&gt; string.find(<span class=quote>"bob"</span>, <span class=quote>"b"</span>, 1, 2)
<br>-1
<br></span></p>



<p>
이 예제에서는 기호 <i>b</i>가 <span class=code>1</span>에서 <span class=code>2</span> 미만까지의 지표 범위에서 나타나지 않기 때문에 탐색이 실패합니다.</p>

<a name=10></a><br>
<h3>7.10 문자 분류</h3>

<p>
한 문자를 조사해 보고 그것이 대문자인지 소문자인지 테스트하고, 또는 그것이 문자(character)인지 숫자(digit)인지 테스트해보는 것이 때로는 도움이 됩니다. <span class=code>string</span> 모듈은 이러한 목적으로 유용하게 사용되는 여러 상수들을 제공합니다.</p>

<p>
문자열 <span class=code>string.lowercase</span>에는 시스템이 소문자라고 간주하는 모든 기호들이 담겨 있습니다. 비슷하게, <span class=code>string.uppercase</span>에는 모든 대문자들이 담겨 있습니다. 다음을 시험해 보고 무엇을 얻는지 살펴 보세요:</p>


<p><span class=code>&gt;&gt;&gt; <span class=keyword>print</span> string.lowercase
<br>&gt;&gt;&gt; <span class=keyword>print</span> string.uppercase
<br>&gt;&gt;&gt; <span class=keyword>print</span> string.digits
<br></span></p>



<p>
이러한 상수들과 <span class=code>find</span>를 사용해서 문자들을 분류할 수 있습니다. 예를 들어, 만약 <span class=code>find(lowercase, ch)</span>가 <span class=code>-1</span> 이 아닌 값을 반환하면, <span class=code>ch</span>는 틀림없이 소문자입니다:</p>


<p><span class=code><span class=keyword>def</span> <span class=function>isLower</span>(ch):
<br>&nbsp; <span class=keyword>return</span> find(string.lowercase, ch) != -1
<br></span></p>



<p>
또다른 방법으로 <span class=code><span class=keyword>in</span></span> 연산자를 이용할 수 있습니다. 이 연산자는 한 문자가 문자열에 나타나는지를 알려줍니다:</p>


<p><span class=code><span class=keyword>def</span> <span class=function>isLower</span>(ch):
<br>&nbsp; <span class=keyword>return</span> ch <span class=keyword>in</span> string.lowercase
<br></span></p>



<p>
또다른 대안으로 비교 연산자를 사용할 수 있습니다:</p>


<p><span class=code><span class=keyword>def</span> <span class=function>isLower</span>(ch):
<br>&nbsp; <span class=keyword>return</span> <span class=quote>'a'</span> &lt;= ch &lt;= <span class=quote>'z'</span>
<br></span></p>



<p>
<span class=code>ch</span>가 <i>a</i>와 <i>z</i>에 있다면 틀림없이 소문자입니다.</p>

<p style="margin-left: 30px; margin-right: 30px;"> <i>연습으로, 어느 버전의 <span class=code>isLower</span>가 가장 빠를지 연구해 보세요. 속도라는 이유를 제외하고 한 함수 또는 다른 함수를 선호하는 다른 이유를 생각할 수 있습니까?</i> </p>

<p>
<span class=code>string</span> 모듈에는 또다른 상수 하나가 정의되어 있는데, 그것을 인쇄해보면 놀랄 것입니다:</p>


<p><span class=code>&gt;&gt;&gt; <span class=keyword>print</span> string.whitespace
<br></span></p>



<p>
공백(<b>Whitespace</b>) 문자들은 아무것도 출력하지 않고서 커서를 이동시킵니다. 공백문자들은 눈에 보이는 문자들 사이에 (적어도 하얀 종이 위에) 빈 공간을 만듭니다. 상수 <span class=code>string.whitespace</span>에는 모든 공백 문자들이 담겨 있는데, 스페이스(space)와 탭(tab (\verb+\t+)) 그리고 새줄(newline (\verb+\n+)) 문자가 포함되어 있습니다.</p>



<p>
<span class=code>string</span> 모듈에는 다른 유용한 함수들이 있습니다. 그러나 이 책은 참조서를 목적으로 하지 않습니다. 반면에 파이썬 라이브러리 참조서(<i>Python Library Reference</i>)는 참조서를 목적으로 합니다. 파이썬 라이브러리 참조서는 다른 풍부한 문서들과 더불어 파이썬 웹사이트인 <span class=code>www.python.org</span>에 가면 얻을 수 있습니다.</p>



<a name=11></a><br>
<h3>7.11 용어 해설</h3>

<dl>

<dt>복합 데이타 형(compound data type)</dt>
<dd>그 자체로 값들인 요소들로 구성되는 데이터유형.</dd>

<dt>순회(traverse)</dt>
<dd>한 모둠이 가지는 요소들을 반복하는 것으로서 각 요소에 대하여 비슷한 연산을 수행한다.</dd>

<dt>지표(index)</dt>
<dd>문자열에서 문자를 선택하는 것처럼, 순서있는 모둠에서 한 구성원을 선택하는데 사용되는 변수나 값.</dd>

<dt>조각(slice)</dt>
<dd>지표의 범위에 의해서 지정되는 문자열의 일부분.</dd>

<dt>변경가능(mutable)</dt>
<dd>복합 데이타 유형으로 이 유형의 원소는 새로운 값에 할당될 수 있다.</dd>

<dt>계수기(counter)</dt>
<dd>무엇인가를 세는데 사용되는 변수, 보통 0으로 초기화되고 그리고 증가된다.</dd>

<dt>증가(increment)</dt>
<dd>한 변수의 값을 하나씩 증가시키는 것.</dd>

<dt>감소(decrement)</dt>
<dd>한 변수의 값을 하나씩 감소시키는 것.</dd>

<dt>공백문자(whitespace)</dt>
<dd>눈에 보이는 문자를 찍지 않고 커서를 이동시키는 모든 문자들. 상수 <span class=code>string.whitespace</span>에는 모든 공백 문자들이 담겨 있다.</dd>



</dl>
<h2>연습문제</h2>

<ol>
<li><div class="exercise">
다음을:
<pre class="python">
prefixes = "JKLMNOPQ"
suffix = "ack"
   
for letter in prefixes:
    print letter + suffix
</pre>
<code>Ouack</code>과 <code>Quack</code>의 철자가 올바르게 되도록 수정하라.
</div></li>

<li><div class="exercise">
다음을
<pre class="python">
fruit = "banana"
count = 0
for char in fruit:
    if char == 'a':
        count += 1
print count
</pre>
<code>count_letters</code>라는 함수 안에 캡슐화해 넣고, 문자열과 기호를 인자로 받도록 일반화하라.
</div></li>

<li><div class="exercise">
이제 문자열을 순회하는 대신에, 반복적으로 <code>find</code>(섹션 8.10에 있는 버전)를 호출하도록 <code>count_letters</code> 함수를 재작성하라. 선택적인 세번째 매개변수로 세고 있는 기호가 새로 나타나는 위치를 지정한다.
</div></li>

<li><div class="exercise">
어느 버전의 <code>is_lower</code>가 더 빠를 것이라고 생각하는가?  두 버전중의 하나를 선호한다면 속도 외에 다른 이유를 생각할 수 있는가? 
</div></li>

<li><div class="exercise">
<code>stringtools.py</code>라는 파일을 만들고 그 안에 다음을 넣어라:
<pre class='python'>
def reverse(s):
    """
      &gt;&gt;&gt; reverse('happy')
      'yppah'
      &gt;&gt;&gt; reverse('Python')
      'nohtyP'
      &gt;&gt;&gt; reverse("")
      ''
      &gt;&gt;&gt; reverse("P")
      'P'
    """

if __name__ == '__main__':
    import doctest
    doctest.testmod()
</pre>
문서화테스트를 통과하도록 함수 몸체를 <code>reverse</code>에 추가하라.
</div></li>

<li><div class="exercise">
<code>mirror</code>를 to <code>stringtools.py</code>에 추가하라.
<pre class='python'>
def mirror(s):
    """
      &gt;&gt;&gt; mirror("good")
      'gooddoog'
      &gt;&gt;&gt; mirror("yes")
      'yessey'
      &gt;&gt;&gt; mirror('Python')
      'PythonnohtyP'
      &gt;&gt;&gt; mirror("")
      ''
      &gt;&gt;&gt; mirror("a")
      'aa'
    """
</pre>
문서화테스트에서 지시한대로 작동하도록 함수 몸체를 작성하라.
</div></li>

<li><div class="exercise">
<code>remove_letter</code>를 <code>stringtools.py</code>에 포함시켜라.
<pre class='python'>
def remove_letter(letter, strng):
    """
      &gt;&gt;&gt; remove_letter('a', 'apple')
      'pple'
      &gt;&gt;&gt; remove_letter('a', 'banana')
      'bnn'
      &gt;&gt;&gt; remove_letter('z', 'banana')
      'banana'
      &gt;&gt;&gt; remove_letter('i', 'Mississippi')
      'Msssspp'
    """
</pre>
문서화테스트에서 지시한대로 작동하도록 함수 몸체를 작성하라.
</div></li>

<li><div class="exercise">
마지막으로, 몸체를 한 번에 하나씩 각각의 다음 함수에 추가하라.
<pre class='python'>
def is_palindrome(s):
    """
      &gt;&gt;&gt; is_palindrome('abba')
      True
      &gt;&gt;&gt; is_palindrome('abab')
      False
      &gt;&gt;&gt; is_palindrome('tenet')
      True
      &gt;&gt;&gt; is_palindrome('banana')
      False
      &gt;&gt;&gt; is_palindrome('straw warts')
      True
    """

def count(sub, s):
    """
      &gt;&gt;&gt; count('is', 'Mississippi')
      2
      &gt;&gt;&gt; count('an', 'banana')
      2
      &gt;&gt;&gt; count('ana', 'banana')
      2
      &gt;&gt;&gt; count('nana', 'banana')
      1
      &gt;&gt;&gt; count('nanan', 'banana')
      0
    """

def remove(sub, s):
    """
      &gt;&gt;&gt; remove('an', 'banana')
      'bana'
      &gt;&gt;&gt; remove('cyc', 'bicycle')
      'bile'
      &gt;&gt;&gt; remove('iss', 'Mississippi')
      'Missippi'
      &gt;&gt;&gt; remove('egg', 'bicycle')
      'bicycle'
    """

def remove_all(sub, s):
    """
      &gt;&gt;&gt; remove_all('an', 'banana')
      'ba'
      &gt;&gt;&gt; remove_all('cyc', 'bicycle')
      'bile'
      &gt;&gt;&gt; remove_all('iss', 'Mississippi')
      'Mippi'
      &gt;&gt;&gt; remove_all('eggs', 'bicycle')
      'bicycle'
    """
</pre>
문서화테스트가 모두 통과할 때까지 말이다.
</div></li>

<li><div class="exercise">
다음의 형식화 문자열 연산을 하나씩 파이썬 쉘에서 시도해 보고 그 결과를 기록하라:
  <ol style="list-style-type: lower-alpha;">
    <li>"%s %d %f" % (5, 5, 5)</li>
    <li>"%-.2f" % 3</li>
    <li>"%-10.2f%-10.2f" % (7, 1.0/2)</li>
    <li>print "  $%5.2f\n  $%5.2f\n  $%5.2f" % (3, 4.5, 11.2)</li>
  </ol>
</div></li>

<li><div class="exercise">
다음의 형식화 문자열은 에러가 있다. 고쳐라:
  <ol style="list-style-type: lower-alpha;">
    <li>"%s %s %s %s" % ('this', 'that', 'something')</li>
    <li>"%s %s %s" % ('yes', 'no', 'up', 'down')</li>
    <li>"%d %f %f" % (3, 3, 'three')</li>
  </ol>
</div></li>
</ol>

<p>
<hr>
<table width="100%" cellpadding="0" cellspacing="2" border="0">
  <tr>
    <td width="20" class=head><a href="chap08.htm"><img border="0" alt="Next" src="images/next.png" ></a></td>
    <td width="20" class=head><a href="index.htm" ><img border="0" alt="Up" src="images/up.png" ></a></td>
    <td width="20" class=head><a href="chap06.htm" ><img border="0" alt="Previous" src="images/prev.png" ></a></td>
    <td width="100%" class=headcenter><img border="0" alt="Hi" src="images/headertitle.png" ></td>
    <td width="20" class=head><img border="0" alt="" src="images/blank.png" ></td>
    <td width="20" class=head><a href="dex.htm" ><img border="0" alt="Index" src="images/index.png" ></a></td>
    <td width="20" class=head><img border="0" alt="" src="images/blank.png" ></td>
  </tr>
</table>
<hr>

</body>
</html>
